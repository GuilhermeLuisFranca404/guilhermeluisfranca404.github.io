{"_path":"/articles/estrutura-de-dados-java/set/tree-set","_dir":"set","_draft":false,"_partial":false,"_locale":"","title":"TreeSet","description":"TreeSet | Série - Fundamentos de Estrutura de Dados Elementar com Java.","image":{"src":"https://gulybyte.github.io/static/images/articles/estrutura-de-dados-java/binary-search-tree-pior-caso-x-red-black-tree.png","alt":"TreeSet Java.","width":2281,"height":742},"head":{"link":[{"rel":"canonical","href":"https://gulybyte.github.io/articles/estrutura-de-dados-java"}],"meta":[{"name":"og:url","content":"https://gulybyte.github.io/articles/estrutura-de-dados-java"},{"property":"og:title","content":"TreeSet"},{"name":"description","content":"TreeSet | Série - Fundamentos de Estrutura de Dados Elementar com Java."},{"name":"excerpt","content":"TreeSet | Série - Fundamentos de Estrutura de Dados Elementar com Java."},{"name":"og:description","content":"TreeSet | Série - Fundamentos de Estrutura de Dados Elementar com Java."},{"name":"application-name","content":"TreeSet | Série - Fundamentos de Estrutura de Dados Elementar com Java."},{"name":"og:site_name","content":"TreeSet | Série - Fundamentos de Estrutura de Dados Elementar com Java."},{"name":"keywords","content":"Java, Estrutura de Dados, Série, Set, TreeSet"},{"name":"og:image","content":"https://gulybyte.github.io/static/images/articles/estrutura-de-dados-java/binary-search-tree-pior-caso-x-red-black-tree.png"},{"name":"og:image:width","content":"2281"},{"name":"og:image:height","content":"742"},{"name":"og:image:type","content":"image/png"}]},"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"treeset"},"children":[{"type":"text","value":"TreeSet."}]},{"type":"element","tag":"h1","props":{"style":"text-align: left; padding: 0em 0em !important; font-size: 2em","id":"serie-fundamentos-de-estrutura-de-dados-elementar-com-java"},"children":[{"type":"text","value":"Serie - Fundamentos de Estrutura de Dados Elementar com Java."}]},{"type":"element","tag":"hr","props":{"id":""},"children":[]},{"type":"element","tag":"h2","props":{"id":"treeset-como-funciona-a-red-black-tree"},"children":[{"type":"text","value":"TreeSet. Como funciona a "},{"type":"element","tag":"span","props":{"style":"color: red;"},"children":[{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"Red"}]}]},{"type":"text","value":"-"},{"type":"element","tag":"span","props":{"style":"color: black;"},"children":[{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"Black"}]}]},{"type":"text","value":" "},{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"Tree"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h5","props":{"id":"o-desafio"},"children":[{"type":"text","value":"O Desafio."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"As árvores, ou \"Trees\", em sua essência, representam estruturas facilmente compreensíveis. No entanto, algumas árvores, como a AVL Tree e a Red-Black Tree, envolvem implementações complexas. No caso do TreeSet, que utiliza o TreeMap, sua implementação se baseia na "},{"type":"element","tag":"span","props":{"style":"color: red;"},"children":[{"type":"text","value":"Red"}]},{"type":"text","value":"-"},{"type":"element","tag":"span","props":{"style":"color: black;"},"children":[{"type":"text","value":"Black"}]},{"type":"text","value":" Tree. Devido à natureza avançada desta estrutura, não abordarei detalhes profundos aqui. Dentre todas as estruturas, esta será a que simplificarei ao máximo, mas a simplificação será suficiente para fornecer noções básicas."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Caso deseje explorar a implementação, recomendo estudar a "},{"type":"element","tag":"span","props":{"style":"color: red;"},"children":[{"type":"text","value":"R"}]},{"type":"element","tag":"span","props":{"style":"color: black;"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"Tree apresentada no "},{"type":"element","tag":"a","props":{"href":"https://www.amazon.com.br/Introduction-Algorithms-Fourth-Thomas-Cormen/dp/026204630X/ref=sr_1_2","rel":["nofollow"],"target":"_blank"},"children":[{"type":"text","value":"livro do Cormen"}]},{"type":"text","value":", pois a "},{"type":"element","tag":"span","props":{"style":"color: red;"},"children":[{"type":"text","value":"R"}]},{"type":"element","tag":"span","props":{"style":"color: black;"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"Tree utilizada no TreeSet é uma adaptação dessa presente no livro."}]},{"type":"element","tag":"h5","props":{"id":"como-funciona-a-tree"},"children":[{"type":"text","value":"Como Funciona a Tree?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Antes de mergulharmos na complexidade da "},{"type":"element","tag":"span","props":{"style":"color: red;"},"children":[{"type":"text","value":"Red"}]},{"type":"text","value":"-"},{"type":"element","tag":"span","props":{"style":"color: black;"},"children":[{"type":"text","value":"Black"}]},{"type":"text","value":" Tree, consideremos um exemplo mais simples de árvore: a Binary Search Tree (BST)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Tree simples estrutura de dados","src":"/static/images/articles/estrutura-de-dados-java/tree-classica.png","position":"auto","width":"30%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Outro exemplo prático: suponhamos o conjunto "},{"type":"element","tag":"code","props":{"tag":"true"},"children":[{"type":"text","value":"{34, 84, 15, 0, 2, 99, 79, 9, 88, 89, 18, 31, 39, 100, 101}"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Binary Search Tree estrutura de dados","src":"/static/images/articles/estrutura-de-dados-java/binary-search-tree.png","position":"auto","width":"70%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ao realizar uma pesquisa nesse conjunto, como, por exemplo, para o elemento "},{"type":"element","tag":"code","props":{"tag":"true"},"children":[{"type":"text","value":"101"}]},{"type":"text","value":", em um array seria necessário percorrer todos os elementos. No entanto, na BST, como evidenciado (veja o diagrama), percorreríamos apenas 4 elementos: "},{"type":"element","tag":"code","props":{"tag":"true"},"children":[{"type":"text","value":"34 -> 84 -> 99 -> 100 -> 101"}]},{"type":"text","value":". Isso é bastante eficiente, concorda?"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Observação: Ao apresentar um conjunto, significa que os elementos foram inseridos na ordem em que aparecem. Além disso, é importante destacar que demonstro o conjunto e, em seguida, como ele é organizado na árvore. Contudo, não entro em detalhes sobre por que a árvore se organiza dessa maneira, uma vez que, conforme especificado, não discutirei a implementação para melhor didática. Caso queira testar seus próprios conjuntos, "},{"type":"element","tag":"a","props":{"href":"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html","rel":["nofollow"],"target":"_blank"},"children":[{"type":"text","value":"consulte isso"}]},{"type":"text","value":"."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"No entanto, a BST (e outras Trees) apresenta um problema: ela pode facilmente se desequilibrar. A BST distribui os elementos menores à esquerda e os maiores à direita, seguindo a sequência de inserção. Em alguns casos, como o conjunto "},{"type":"element","tag":"code","props":{"tag":"true"},"children":[{"type":"text","value":"{99, 89, 100, 101, 102, 103, 104, 105, 106}"}]},{"type":"text","value":", a árvore pode se tornar desbalanceada."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Binary Search Tree Pior Caso estrutura de dados","src":"/static/images/articles/estrutura-de-dados-java/binary-search-tree-pior-caso.png","position":"auto","width":"60%"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Agora, pense: para encontrar o elemento "},{"type":"element","tag":"code","props":{"tag":"true"},"children":[{"type":"text","value":"106"}]},{"type":"text","value":", precisamos percorrer quase toda a árvore. Nesses casos, surge a necessidade de uma árvore de busca balanceada. Existem várias implementações que atendem a essa necessidade, e a utilizada no TreeSet é a "},{"type":"element","tag":"span","props":{"style":"color: red;"},"children":[{"type":"text","value":"Red"}]},{"type":"text","value":"-"},{"type":"element","tag":"span","props":{"style":"color: black;"},"children":[{"type":"text","value":"Black"}]},{"type":"text","value":" Tree."}]},{"type":"element","tag":"h2","props":{"id":"como-funciona-a-rb-tree"},"children":[{"type":"text","value":"Como funciona a "},{"type":"element","tag":"span","props":{"style":"color: red;"},"children":[{"type":"text","value":"R"}]},{"type":"element","tag":"span","props":{"style":"color: black;"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":" Tree?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"A diferença fundamental entre a "},{"type":"element","tag":"span","props":{"style":"color: red;"},"children":[{"type":"text","value":"Red"}]},{"type":"text","value":"-"},{"type":"element","tag":"span","props":{"style":"color: black;"},"children":[{"type":"text","value":"Black"}]},{"type":"text","value":" Tree e a BST é que a "},{"type":"element","tag":"span","props":{"style":"color: red;"},"children":[{"type":"text","value":"R"}]},{"type":"element","tag":"span","props":{"style":"color: black;"},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"Tree possui um campo que \"define as cores\", sendo elas "},{"type":"element","tag":"span","props":{"style":"color: red;"},"children":[{"type":"text","value":"Vermelho ("},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"R"}]},{"type":"text","value":"ed)"}]},{"type":"text","value":" e "},{"type":"element","tag":"span","props":{"style":"color: black;"},"children":[{"type":"text","value":"Preto ("},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"B"}]},{"type":"text","value":"lack)"}]},{"type":"text","value":". Vale ressaltar que essas \"cores\" são representadas, na realidade, por um campo de 1 bit (boolean), geralmente associando o bit 1 à cor vermelha e o bit 0 à cor preta."}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"A partir de agora, chamaremos os elementos da árvore pelo nome correto, que é \"Nó\" (Node)!"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"O nó raiz (o primeiro) é sempre preto, e por padrão, ao criar um novo nó, ele será vermelho. A regra geral é que um nó vermelho só pode ter nós pais e filhos da cor preta. Os últimos nós (comumente chamados de \"folhas\") são nós vazios, que servem principalmente para garantir que os ponteiros dos verdadeiros últimos nós não sejam nulos, seguindo a regra das cores. A Red-Black Tree consegue reequilibrar esses nós por meio de rotações (basicamente, uma troca de ponteiros) de modo a manter a árvore bem balanceada. Veja um exemplo com nossos conjuntos anteriores ("},{"type":"element","tag":"code","props":{"tag":"true"},"children":[{"type":"text","value":"{34, 84, 15, 0, 2, 99, 79, 9, 88, 89, 18, 31, 39, 100, 101}"}]},{"type":"text","value":" e "},{"type":"element","tag":"code","props":{"tag":"true"},"children":[{"type":"text","value":"{99, 89, 100, 101, 102, 103, 104, 105, 106}"}]},{"type":"text","value":"):"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Binary Search Tree x Red-Black Tree estrutura de dados","src":"/static/images/articles/estrutura-de-dados-java/binary-search-tree-x-red-black-tree.png"},"children":[]}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"no pior caso (note o balanceamente):"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Binary Search Tree Pior Caso x Red-Black Tree estrutura de dados","src":"/static/images/articles/estrutura-de-dados-java/binary-search-tree-pior-caso-x-red-black-tree.png"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"ok-mas-e-o-treeset"},"children":[{"type":"text","value":"Ok. Mas e o TreeSet?"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"O TreeSet opera com base nesse conceito, com a diferença de que não são permitidos nós repetidos. Além disso, no TreeSet, o conceito de Árvore Vermelho e Preta (Red-Black Tree) é estendido para manter a ordenação. Essa ordenação é mantida por meio de um conjunto que utiliza a ordem natural, quer um "},{"type":"element","tag":"a","props":{"href":"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Comparator.html","rel":["nofollow"],"target":"_blank"},"children":[{"type":"text","value":"comparador"}]},{"type":"text","value":" explícito seja fornecido ou não. Dessa forma, temos o HashSet sem ordenação, o LinkedHashSet ordenando apenas por inserção e o TreeSet utilizando um "},{"type":"element","tag":"code","props":{"tag":"true"},"children":[{"type":"text","value":"Comparator"}]},{"type":"text","value":"."}]},{"type":"element","tag":"h2","props":{"id":"vantagens-e-desvantagens"},"children":[{"type":"text","value":"Vantagens e Desvantagens"}]},{"type":"element","tag":"h5","props":{"id":"vantagens"},"children":[{"type":"text","value":"Vantagens"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" -"}]},{"type":"text","value":" Mantém os elementos em ordem natural ou com base em um comparador, permitindo a realização de operações eficientes de conjunto."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"2"}]},{"type":"text","value":" -"}]},{"type":"text","value":" Implementação de árvore "},{"type":"element","tag":"span","props":{"style":"color: red;"},"children":[{"type":"text","value":"Red"}]},{"type":"text","value":"-"},{"type":"element","tag":"span","props":{"style":"color: black;"},"children":[{"type":"text","value":"Black"}]},{"type":"text","value":" Tree eficiente."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"3"}]},{"type":"text","value":" -"}]},{"type":"text","value":" Suporta operações como encontrar o elemento sucessor ou predecessor."}]}]},{"type":"element","tag":"h5","props":{"id":"desvantagens"},"children":[{"type":"text","value":"Desvantagens"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" -"}]},{"type":"text","value":" Operações de inserção, remoção e pesquisa podem ter desempenho ligeiramente inferior em comparação com HashSet (apenas para os melhores casos)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"element","tag":"code","props":{},"children":[{"type":"text","value":"2"}]},{"type":"text","value":" -"}]},{"type":"text","value":" Ocupa mais espaço que HashSet devido à necessidade de armazenar nós adicionais na árvore."}]}]},{"type":"element","tag":"h4","props":{"id":"uso-comum"},"children":[{"type":"text","value":"Uso comum"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Manutenção de elementos ordenados em uma coleção, útil em cenários que exigem iteração em ordem."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Cenário de uso:"}]},{"type":"text","value":" Em um sistema de calendário, um TreeSet pode ser usado para armazenar os compromissos agendados, garantindo que eles sejam recuperados e exibidos na ordem correta."}]},{"type":"element","tag":"next-content","props":{"content":"Fim da Série. Retorne a home.","linkcontent":"/articles"},"children":[]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"treeset-como-funciona-a-red-black-tree","depth":2,"text":"TreeSet. Como funciona a Red-Black Tree."},{"id":"como-funciona-a-rb-tree","depth":2,"text":"Como funciona a RB Tree?"},{"id":"vantagens-e-desvantagens","depth":2,"text":"Vantagens e Desvantagens"}]}},"_type":"markdown","_id":"content:articles:estrutura-de-dados-java:set:tree-set.md","_source":"content","_file":"articles/estrutura-de-dados-java/set/tree-set.md","_extension":"md"}